{"ast":null,"code":"import { call, put, select, takeLatest, delay } from 'redux-saga/effects';\nimport { request } from 'utils/request';\nimport { selectUsername } from './selectors';\nimport { githubRepoFormActions as actions } from '.';\nimport { RepoErrorType } from './types';\n\n/**\n * Github repos request/response handler\n */\nexport function* getRepos() {\n  yield delay(500);\n  // Select username from store\n  const username = yield select(selectUsername);\n  if (username.length === 0) {\n    yield put(actions.repoError(RepoErrorType.USERNAME_EMPTY));\n    return;\n  }\n  const requestURL = `https://api.github.com/users/${username}/repos?type=all&sort=updated`;\n  try {\n    // Call our request helper (see 'utils/request')\n    const repos = yield call(request, requestURL);\n    if ((repos === null || repos === void 0 ? void 0 : repos.length) > 0) {\n      yield put(actions.reposLoaded(repos));\n    } else {\n      yield put(actions.repoError(RepoErrorType.USER_HAS_NO_REPO));\n    }\n  } catch (err) {\n    var _err$response;\n    if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 404) {\n      yield put(actions.repoError(RepoErrorType.USER_NOT_FOUND));\n    } else if (err.message === 'Failed to fetch') {\n      yield put(actions.repoError(RepoErrorType.GITHUB_RATE_LIMIT));\n    } else {\n      yield put(actions.repoError(RepoErrorType.RESPONSE_ERROR));\n    }\n  }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport function* githubRepoFormSaga() {\n  // Watches for loadRepos actions and calls getRepos when one comes in.\n  // By using `takeLatest` only the result of the latest API call is applied.\n  // It returns task descriptor (just like fork) so we can continue execution\n  // It will be cancelled automatically on component unmount\n  yield takeLatest(actions.loadRepos.type, getRepos);\n}","map":{"version":3,"names":["call","put","select","takeLatest","delay","request","selectUsername","githubRepoFormActions","actions","RepoErrorType","getRepos","username","length","repoError","USERNAME_EMPTY","requestURL","repos","reposLoaded","USER_HAS_NO_REPO","err","response","status","USER_NOT_FOUND","message","GITHUB_RATE_LIMIT","RESPONSE_ERROR","githubRepoFormSaga","loadRepos","type"],"sources":["/Users/jeonsohee/Desktop/todo/src/app/pages/HomePage/Features/GithubRepoForm/slice/saga.ts"],"sourcesContent":["import { call, put, select, takeLatest, delay } from 'redux-saga/effects';\nimport { request } from 'utils/request';\nimport { selectUsername } from './selectors';\nimport { githubRepoFormActions as actions } from '.';\nimport { Repo } from 'types/Repo';\nimport { RepoErrorType } from './types';\n\n/**\n * Github repos request/response handler\n */\nexport function* getRepos() {\n  yield delay(500);\n  // Select username from store\n  const username: string = yield select(selectUsername);\n  if (username.length === 0) {\n    yield put(actions.repoError(RepoErrorType.USERNAME_EMPTY));\n    return;\n  }\n  const requestURL = `https://api.github.com/users/${username}/repos?type=all&sort=updated`;\n\n  try {\n    // Call our request helper (see 'utils/request')\n    const repos: Repo[] = yield call(request, requestURL);\n    if (repos?.length > 0) {\n      yield put(actions.reposLoaded(repos));\n    } else {\n      yield put(actions.repoError(RepoErrorType.USER_HAS_NO_REPO));\n    }\n  } catch (err: any) {\n    if (err.response?.status === 404) {\n      yield put(actions.repoError(RepoErrorType.USER_NOT_FOUND));\n    } else if (err.message === 'Failed to fetch') {\n      yield put(actions.repoError(RepoErrorType.GITHUB_RATE_LIMIT));\n    } else {\n      yield put(actions.repoError(RepoErrorType.RESPONSE_ERROR));\n    }\n  }\n}\n\n/**\n * Root saga manages watcher lifecycle\n */\nexport function* githubRepoFormSaga() {\n  // Watches for loadRepos actions and calls getRepos when one comes in.\n  // By using `takeLatest` only the result of the latest API call is applied.\n  // It returns task descriptor (just like fork) so we can continue execution\n  // It will be cancelled automatically on component unmount\n  yield takeLatest(actions.loadRepos.type, getRepos);\n}\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,GAAG,EAAEC,MAAM,EAAEC,UAAU,EAAEC,KAAK,QAAQ,oBAAoB;AACzE,SAASC,OAAO,QAAQ,eAAe;AACvC,SAASC,cAAc,QAAQ,aAAa;AAC5C,SAASC,qBAAqB,IAAIC,OAAO,QAAQ,GAAG;AAEpD,SAASC,aAAa,QAAQ,SAAS;;AAEvC;AACA;AACA;AACA,OAAO,UAAUC,QAAQ,GAAG;EAC1B,MAAMN,KAAK,CAAC,GAAG,CAAC;EAChB;EACA,MAAMO,QAAgB,GAAG,MAAMT,MAAM,CAACI,cAAc,CAAC;EACrD,IAAIK,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;IACzB,MAAMX,GAAG,CAACO,OAAO,CAACK,SAAS,CAACJ,aAAa,CAACK,cAAc,CAAC,CAAC;IAC1D;EACF;EACA,MAAMC,UAAU,GAAI,gCAA+BJ,QAAS,8BAA6B;EAEzF,IAAI;IACF;IACA,MAAMK,KAAa,GAAG,MAAMhB,IAAI,CAACK,OAAO,EAAEU,UAAU,CAAC;IACrD,IAAI,CAAAC,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEJ,MAAM,IAAG,CAAC,EAAE;MACrB,MAAMX,GAAG,CAACO,OAAO,CAACS,WAAW,CAACD,KAAK,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,MAAMf,GAAG,CAACO,OAAO,CAACK,SAAS,CAACJ,aAAa,CAACS,gBAAgB,CAAC,CAAC;IAC9D;EACF,CAAC,CAAC,OAAOC,GAAQ,EAAE;IAAA;IACjB,IAAI,kBAAAA,GAAG,CAACC,QAAQ,kDAAZ,cAAcC,MAAM,MAAK,GAAG,EAAE;MAChC,MAAMpB,GAAG,CAACO,OAAO,CAACK,SAAS,CAACJ,aAAa,CAACa,cAAc,CAAC,CAAC;IAC5D,CAAC,MAAM,IAAIH,GAAG,CAACI,OAAO,KAAK,iBAAiB,EAAE;MAC5C,MAAMtB,GAAG,CAACO,OAAO,CAACK,SAAS,CAACJ,aAAa,CAACe,iBAAiB,CAAC,CAAC;IAC/D,CAAC,MAAM;MACL,MAAMvB,GAAG,CAACO,OAAO,CAACK,SAAS,CAACJ,aAAa,CAACgB,cAAc,CAAC,CAAC;IAC5D;EACF;AACF;;AAEA;AACA;AACA;AACA,OAAO,UAAUC,kBAAkB,GAAG;EACpC;EACA;EACA;EACA;EACA,MAAMvB,UAAU,CAACK,OAAO,CAACmB,SAAS,CAACC,IAAI,EAAElB,QAAQ,CAAC;AACpD"},"metadata":{},"sourceType":"module","externalDependencies":[]}